<?php

/**
 * The MIT License
 *
 * Copyright 2017 Austrian Centre for Digital Humanities.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 * @package repo-php-util
 * @copyright (c) 2017, Austrian Centre for Digital Humanities
 * @license https://opensource.org/licenses/MIT
 */

namespace acdhOeaw\util;

use RuntimeException;
use DomainException;
use InvalidArgumentException;
use EasyRdf\Graph;
use EasyRdf\Resource;
use acdhOeaw\fedora\Fedora;
use acdhOeaw\fedora\FedoraResource;
use acdhOeaw\fedora\exceptions\NotFound;
use acdhOeaw\fedora\exceptions\NoAcdhId;
use acdhOeaw\fedora\metadataQuery\Query;
use acdhOeaw\fedora\metadataQuery\HasProperty;
use acdhOeaw\util\RepoConfig as RC;

/**
 * Class for importing whole metadata graph into the repository.
 *
 * @author zozlak
 */
class MetadataCollection extends Graph {

    const SKIP   = 1;
    const CREATE = 2;

    /**
     * Turns debug messages on
     * @var bool
     */
    static public $debug = false;

    /**
     * Makes given resource a proper agent
     * 
     * @param \EasyRdf\Resource $res
     * @return \EasyRdf\Resource
     */
    static public function makeAgent(Resource $res): Resource {
        $res->addResource('http://www.w3.org/1999/02/22-rdf-syntax-ns#type', 'http://xmlns.com/foaf/0.1/Agent');

        return $res;
    }

    /**
     * Fedora connection object
     * @var \acdhOeaw\fedora\Fedora
     */
    private $fedora;

    /**
     * Parent resource for all imported graph nodes
     * @var \acdhOeaw\fedora\FedoraResource
     */
    private $resource;

    /**
     * Fedora path in the repo where imported resources are created.
     * @var string
     */
    private $fedoraLoc = '/';

    /**
     * Creates a new metadata parser.
     * 
     * @param Fedora $fedora
     * @param string $file
     * @param string $format
     */
    public function __construct(Fedora $fedora, string $file,
                                string $format = null) {
        parent::__construct();
        $this->parseFile($file, $format);

        $this->fedora = $fedora;
    }

    /**
     * Sets the repository resource being parent of all resources in the
     * graph imported by the import() method.
     * 
     * @param FedoraResource $res
     * @see import()
     */
    public function setResource(FedoraResource $res) {
        $this->resource = $res;
    }

    /**
     * Sets a location where the resource will be placed.
     * 
     * Can be absolute (but will be sanitized anyway) or relative to the 
     * repository root.
     * 
     * Given location must already exist.
     * 
     * Note that this parameter is used ONLY if the resource DOES NOT EXISTS.
     * If it exists already, its location is not changed.
     * 
     * @param string $fedoraLoc fedora location 
     */
    public function setFedoraLocation(string $fedoraLoc) {
        $this->fedoraLoc = $fedoraLoc;
    }

    /**
     * Imports the whole graph by looping over all resources.
     * 
     * A repository resource is created for every node containing at least one 
     * cfg:fedoraIdProp property and:
     * - containg at least one other property
     * - or being within $namespace
     * - or when $singleOutNmsp equals to MetadataCollection::CREATE
     * 
     * Resources without cfg:fedoraIdProp property are skipped as we are unable
     * to identify them on the next import (which would lead to duplication).
     * 
     * Resource with a fully qualified URI is considered as having
     * cfg:fedoraIdProp (its URI is taken as cfg:fedoraIdProp property value).
     * 
     * Resources in the graph can denote relationships in any way but all
     * object URIs already existing in the repository and all object URIs in the
     * $namespace will be turned into ACDH ids.
     * This means graph can not contain circular dependencies between resources
     * which do not already exist in the repository, like:
     * ```
     * _:a some:Prop _:b .
     * _:b some:Prop _:a .
     * ```
     * The $errorOnCycle parameter determines behaviour of the method when such
     * a cycle exists in the graph.
     * 
     * @param string $namespace repository resources will be created for all
     *   resources in this namespace
     * @param int $singleOutNmsp should repository resources be created
     *   representing URIs outside $namespace (MetadataCollection::SKIP or
     *   MetadataCollection::CREATE)
     * @return array
     * @throws InvalidArgumentException
     */
    public function import(string $namespace, int $singleOutNmsp): array {
        $dict = array(self::SKIP, self::CREATE);
        if (!in_array($singleOutNmsp, $dict)) {
            throw new InvalidArgumentException('singleOutNmsp parameters must be one of MetadataCollection::SKIP, MetadataCollection::CREATE');
        }

        $this->removeLiteralIds();
        $this->promoteUrisToIds();
        $toBeImported    = $this->filterResources($namespace, $singleOutNmsp);
        $fedoraResources = $this->assureUuids($toBeImported);

        foreach ($toBeImported as $res) {
            $uri       = $res->getUri();
            $fedoraRes = $fedoraResources[$uri];

            echo self::$debug ? "Importing " . $uri . "\n" : "";
            $this->sanitizeResource($res, $namespace);

            echo self::$debug ? "\tupdating " . $fedoraRes->getUri(true) . "\n" : "";
            $meta = $fedoraRes->getMetadata();
            $meta->merge($res, array(RC::idProp()));
            $fedoraRes->setMetadata($meta, false);
            $fedoraRes->updateMetadata();
        }
        return array_values($fedoraResources);
    }

    /**
     * Returns set of resources to be imported skipping all other.
     * @param string $namespace repository resources will be created for all
     *   resources in this namespace
     * @param int $singleOutNmsp should repository resources be created
     *   representing URIs outside $namespace (MetadataCollection::SKIP or
     *   MetadataCollection::CREATE)
     * @return array
     */
    private function filterResources(string $namespace, int $singleOutNmsp): array {
        $result = array();

        echo self::$debug ? "Filtering resources...\n" : '';
        foreach ($this->resources() as $res) {
            echo self::$debug ? "\t" . $res->getUri() . "\n" : '';

            $nonIdProps = array_diff($res->propertyUris(), array(RC::idProp()));
            $inNmsp     = false;
            $ids        = array();
            foreach ($res->allResources(RC::idProp()) as $id) {
                $id     = $id->getUri();
                $ids[]  = $id;
                $inNmsp = $inNmsp || strpos($id, $namespace) === 0;
            }

            if (count($ids) == 0) {
                echo self::$debug ? "\t\tskipping - no ids\n" : '';
            } elseif ($this->fedora->isAcdhId($res->getUri())) {
                echo self::$debug ? "\t\tskipping - ACDH UUID\n" : '';
            } elseif (count($nonIdProps) == 0 && $this->isIdElsewhere($res)) {
                echo self::$debug ? "\t\tskipping - single id assigned to another resource\n" : '';
            } elseif (count($nonIdProps) == 0 && $singleOutNmsp !== MetadataCollection::CREATE && !$inNmsp) {
                echo self::$debug ? "\t\tskipping - onlyIds, outside namespace and mode == MetadataCollection::SKIP\n" : '';
            } else {
                echo self::$debug ? "\t\tincluding\n" : '';
                $result[] = $res;
            }
        }

        return $result;
    }

    /**
     * Assures all resource to be imported have proper UUIDs so references to
     * them can be set correctly.
     * @param array $resources resource to be checked
     * @return array
     */
    private function assureUuids(array $resources): array {
        echo self::$debug ? "Assuring all resources to be imported have ACDH UUIDs...\n" : '';

        $result = array();
        $map    = array();
        foreach ($resources as $res) {
            echo self::$debug ? "\t" . $res->getUri() . "\n" : '';

            $ids = array();
            foreach ($res->allResources(RC::idProp()) as $id) {
                $ids[] = $id->getUri();
            }

            $found = 'found';
            try {
                $fedoraRes = $this->fedora->getResourceByIds($ids);
            } catch (NotFound $e) {
                $meta = (new Graph())->resource('.');
                foreach ($ids as $id) {
                    $meta->addResource(RC::idProp(), $id);
                }
                $meta->addLiteral(RC::titleProp(), 'title stub created by the MetadataCollection');
                $fedoraRes = $this->fedora->createResource($meta);
                $found     = 'new';
            }
            echo self::$debug ? "\t\t" . $found . ' ' . $fedoraRes->getId() . "\n" : '';

            $result[$res->getUri()] = $fedoraRes;
            $map[$res->getUri()]    = $fedoraRes->getId();
        }

        echo self::$debug ? "Mapping objects to ACDH UUIDs...\n" : '';
        foreach ($resources as $res) {
            $properties = array_diff($res->propertyUris($res), array(RC::idProp()));
            foreach ($properties as $prop) {
                foreach ($res->allResources($prop) as $value) {
                    $uri = $value->getUri();
                    if (isset($map[$uri])) {
                        $res->delete($prop, $value);
                        $res->addResource($prop, $map[$uri]);
                        echo self::$debug ? "\t" . $res->getUri() . " " . $prop . " " . $uri . " to " . $map[$uri] . "\n" : '';
                    }
                }
            }
        }

        return $result;
    }

    /**
     * Checks if a given resource is a cfg:fedoraIdProp of some other node in
     * the graph.
     * 
     * @param Resource $res
     * @return bool
     */
    private function isIdElsewhere(Resource $res): bool {
        $idProp = RC::idProp();

        $revMatches = $this->reversePropertyUris($res);
        foreach ($revMatches as $prop) {
            if ($prop != $idProp) {
                continue;
            }
            $matches = $this->resourcesMatching($prop, $res);
            foreach ($matches as $i) {
                if ($i->getUri() != $res->getUri()) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks if a node contains wrong edges (blank ones or non-id edges
     * pointing to ids in $namespace but not being ACDH UUIDs).
     * 
     * @param Resource $res
     * @param string $namespace
     * @return boolean
     */
    private function containsWrongRefs(Resource $res, string $namespace): bool {
        $idProp = RC::idProp();
        foreach ($res->propertyUris() as $prop) {
            if ($prop == $idProp) {
                continue;
            }
            foreach ($res->allResources($prop) as $val) {
                $valUri   = $val->getUri();
                $inNmsp   = strpos($valUri, $namespace) === 0;
                $isAcdhId = $this->fedora->isAcdhId($valUri);
                if ($val->isBNode() || ($inNmsp && !$isAcdhId)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Promotes subjects being fully qualified URLs to ids.
     */
    private function promoteUrisToIds() {
        $idProp = RC::idProp();

        echo self::$debug ? "Promoting URIs to ids..." : '';
        foreach ($this->resources() as $i) {
            if (!$i->isBNode()) {
                echo "\t" . $i->getUri() . "\n";
                $i->addResource($idProp, $i->getUri());
            }
        }
    }

    /**
     * Cleans up resource metadata.
     * 
     * @param Resource $res
     * @param string $namespace
     * @return Resource
     * @throws InvalidArgumentException
     */
    private function sanitizeResource(Resource $res, string $namespace): Resource {
        $this->fedora->fixMetadataReferences($res);
        if ($this->containsWrongRefs($res, $namespace)) {
            echo $res->copy()->getGraph()->serialise('ntriples') . "\n";
            throw new InvalidArgumentException('resource contains references to blank nodes');
        }

        if (count($res->allLiterals(RC::titleProp())) == 0) {
            $res->addLiteral(RC::titleProp(), $res->getResource(RC::idProp()));
        }


        if ($res->isA('http://xmlns.com/foaf/0.1/Person') || $res->isA('http://xmlns.com/foaf/0.1/Agent')) {
            $res = self::makeAgent($res);
        }

        if ($this->resource !== null) {
            $res->addResource(RC::relProp(), $this->resource->getId());
        }

        return $res;
    }

    /**
     * Removes literal ids from the graph.
     */
    private function removeLiteralIds() {
        echo self::$debug ? "Removing literal ids...\n" : "";

        $idProp = RC::idProp();
        foreach ($this->resources() as $i) {
            foreach ($i->allLiterals($idProp) as $j) {
                $i->delete($idProp, $j);
                if (self::$debug) {
                    echo "\tremoved " . $j . " from " . $i->getUri() . "\n";
                }
            }
        }
    }

}

